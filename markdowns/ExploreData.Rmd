---
title: "Grenada: Mangrove Hydrology Considerations for Restorations"
author: "Jody Daniel"
date: "`r Sys.Date()`"
output: 
 markdowntemplates::bulma:
    highlight: tango
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(readxl)
library(stringi)
library(stringr)
library(vegan)
library(writexl)
library(ggthemes)
library(ggrepel)
library(viridis)
library(ggforce)
library(sda)
library(sysfonts)
library(viridis)
library(RColorBrewer)
library(sf)
library(terra)
library(tweedie)
library(statmod)
library(tidyterra) 

```

# Background{.tabset}

Understanding how environmental factors influence mangrove establishment and growth is critical for effective restoration planning. Mangrove species exhibit distinct zonation patterns driven by their differential tolerance to environmental stresses including tidal exposure, salinity gradients, soil drainage, and nutrient availability. These environmental constraints operate at multiple scales, from broad landscape gradients that determine species occurrence to fine-scale microhabitat conditions that influence growth performance.

Our analysis examines how topographic wetness index (groundwater accessibility), flow accumulation (surface water patterns), and elevation (integrating tidal exposure, salinity, and drainage effects) structure mangrove communities across Grenada's coastal wetlands. We explore these relationships through relative performance metrics that compare species' responses to environmental conditions, revealing the ecological niches and environmental tolerances that guide restoration site selection.

## Environmental Data Processing{.tabset}

To ensure robust modeling and consistent predictions across the landscape, we apply a systematic data processing workflow to all environmental variables:

**Clipping to Study Area**: All rasters are first clipped to the soil vector boundaries to focus analysis on areas where mangroves could potentially establish, removing irrelevant offshore or upland areas from consideration.

**Variable Transformations**: All continuous environmental variables (topographic wetness index, flow accumulation, and elevation) undergo asinh (inverse hyperbolic sine) transformation to address potential skewness and extreme values. The asinh transformation is superior to log transformations because it handles zero and negative values naturally while still compressing extreme values, making the data more suitable for linear modeling. This transformation stabilizes variance across the range of each variable and helps meet model assumptions.

**Landscape-Based Scaling**: After transformation, all continuous variables are standardized using landscape-wide statistics (mean and standard deviation) calculated from the clipped rasters themselves. This approach captures the true environmental gradients available across the study area, rather than being limited to the range of conditions where field sampling occurred. Standardization also enables direct comparison of effect sizes between different environmental variables in our models.

**Consistent Extraction**: All field survey points, background points, and spatial predictions extract values from the same pre-processed raster layers, ensuring perfect consistency between model training and landscape-scale prediction. This eliminates scaling mismatches that commonly cause prediction failures in spatial models.

The relative performance approach allows us to identify optimal environmental conditions for each species while accounting for their different maximum growth potentials. By examining how tree height varies across environmental gradients, we can predict both where species will establish and where they are likely to achieve optimal growth, supporting evidence-based restoration decisions that maximize establishment success and long-term performance.

```{r PrepareData, include=FALSE}
# Load and project spatial data layers
SoilVector <- st_read(paste0(here::here(),"/data/Soils.shp"))
# Update the existing S_FAMILY column with complete soil names
SoilMapping <- SoilVector%>% 
    st_drop_geometry() %>%
    select(S_SORT, S_FAMILY) %>%
    filter(!is.na(S_FAMILY)) %>%
    distinct(S_SORT, S_FAMILY) %>%
    arrange(S_SORT)

RiverVector <- st_read(paste0(here::here(),"/data/Rivers.shp")) %>%
  st_transform(crs = crs(SoilVector))

GrenadaOutlineVector <- st_read(paste0(here::here(),"/data/grd_admbnda_adm0_cdema_20240709.shp")) %>%
  st_transform(crs = crs(SoilVector))

# Load and project raw environmental rasters (for extraction)
FARasterRaw <- rast(paste0(here::here(),"/data/GrenadaGrenadines_FlowAccumulation_WGS_1984_20N.tif")) %>%
  terra::project(crs(SoilVector))

TWIRasterRaw <- rast(paste0(here::here(),"/data/GrenadaGrenadines_TWI_WGS_1984_20N.tif")) %>%
  terra::project(crs(SoilVector))

DEMRasterRaw <- rast(paste0(here::here(),"/data/Grenada Land Use and DEM/GrenadaGrenadines_DEM_WGS_1984_20N.tif")) %>%
  terra::project(crs(SoilVector))

# Create processed layers for environmental stack (clipped, transformed, scaled)
FARaster <- FARasterRaw %>%
  {terra::mask(terra::crop(., GrenadaOutlineVector), GrenadaOutlineVector)} %>%
  asinh() %>%
  {(. - global(., "mean", na.rm = TRUE)[[1]]) / global(., "sd", na.rm = TRUE)[[1]]}

TWIRaster <- TWIRasterRaw %>%
  {terra::mask(terra::crop(., GrenadaOutlineVector), GrenadaOutlineVector)} %>%
  asinh() %>%
  {(. - global(., "mean", na.rm = TRUE)[[1]]) / global(., "sd", na.rm = TRUE)[[1]]}

DEMRaster <- DEMRasterRaw %>%
  {terra::mask(terra::crop(., GrenadaOutlineVector), GrenadaOutlineVector)} %>%
  asinh() %>%
  {(. - global(., "mean", na.rm = TRUE)[[1]]) / global(., "sd", na.rm = TRUE)[[1]]}

# Create distance rasters (already clipped by design)
DistanceToCoastRaster <- GrenadaOutlineVector %>%
  vect() %>%
  {terra::rasterize(., DEMRaster)} %>%
  terra::distance() %>%
  {terra::mask(., GrenadaOutlineVector)} %>%
  {(. - global(., "mean", na.rm = TRUE)[[1]]) / global(., "sd", na.rm = TRUE)[[1]]}

DistanceToRiverRaster <- RiverVector %>%
  vect() %>%
  {terra::rasterize(., DEMRaster)} %>%
  terra::distance() %>%
  {terra::mask(., GrenadaOutlineVector)} %>%
  {(. - global(., "mean", na.rm = TRUE)[[1]]) / global(., "sd", na.rm = TRUE)[[1]]}

# Land use raster processed directly (not clipped)
LandUseRaster <- rast(paste0(here::here(),"/data/Grenada_LandUse_WGS_1984_20N.tif")) %>%
  terra::project(crs(SoilVector)) %>%
  terra::resample(TWIRaster, method = "near") %>%
  round() 

TestMetrix<-
  matrix(c(
    1, 4,   # Nutmeg and mixed woody agriculture -> Agriculture/Modified
    2, 4,   # Pastures, cultivated land and herbaceous agriculture -> Agriculture/Modified
    3, 1,   # Semi- or Drought Deciduous, coastal Evergreen and mixed forest or shrubland -> Coastal/Lowland Natural
    4, 3,   # Lowland forest (Evergreen and seasonal Evergreen) -> Lowland Forest
    5, 2,   # Semi-deciduous Forest -> Lowland Forest
    6, 3,   # Evergreen and seasonal Evergreen forest -> Upland/Montane Forest
    7, 3,   # Elfin and Sierra Palm tall cloud forest -> Upland/Montane Forest
    8, 1,   # Bare ground (sand, rock, beaches) -> Coastal/Lowland Natural
    9, 5,   # Water -> Unsuitable
    10, 5,  # Buildings -> Unsuitable
    11, 5,  # Roads and other built-up surfaces -> Unsuitable
    12, 5,  # Golf course -> Agriculture/Modified
    13, 1,  # Wetland -> Coastal/Lowland Natural
    14, 1,  # Mangrove -> Coastal/Lowland Natural
    15, 5   # Quarry -> Unsuitable
  ))





SoilRaster <- as.factor(terra::rasterize(SoilVector, TWIRaster, field = "S_SORT", touches = TRUE)%>% round())

levels(SoilRaster)<- SoilMapping%>% rename(ID = S_SORT,
                                           Category = S_FAMILY)

# Create environmental stack for predictions
EnvStack <- c(TWIRaster, FARaster, DEMRaster,  DistanceToCoastRaster, DistanceToRiverRaster)
names(EnvStack) <- c("TWI", "FA", "Elevation",  "DistanceToCoast", "DistanceToRiver")



# Prepare extraction statistics from clipped rasters for consistent scaling
FA_mean <- global(asinh(terra::mask(terra::crop(FARasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "mean", na.rm = TRUE)[[1]]
FA_sd <- global(asinh(terra::mask(terra::crop(FARasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "sd", na.rm = TRUE)[[1]]

TWI_mean <- global(asinh(terra::mask(terra::crop(TWIRasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "mean", na.rm = TRUE)[[1]]
TWI_sd <- global(asinh(terra::mask(terra::crop(TWIRasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "sd", na.rm = TRUE)[[1]]

DEM_mean <- global(asinh(terra::mask(terra::crop(DEMRasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "mean", na.rm = TRUE)[[1]]
DEM_sd <- global(asinh(terra::mask(terra::crop(DEMRasterRaw, GrenadaOutlineVector), GrenadaOutlineVector)), "sd", na.rm = TRUE)[[1]]

# Load and prepare field data
VegDataCompleteUpdate <- read_excel(paste0(here::here(), "/data/GEF-SGP_Mangrove_Monitoring.xlsx")) %>%
  # Create site information   
  mutate(
    SiteName = case_when(
      str_detect(`Site name`, "Land Aux Epines") ~ "Lans Aux Epines",
      str_detect(`Site name`, "Beausejour") ~ "Beausejour",
      TRUE ~ `Site name`
    ),
    SiteCode = case_when(
      str_detect(SiteName, "Lans Aux Epines") ~ "LAE",
      str_detect(SiteName, "Beausejour") ~ "BS",
      TRUE ~ "OTH"
    ),
    SiteType = case_when(
      str_detect(SiteName, "Lans Aux Epines") ~ "Fringe",
      str_detect(SiteName, "Beausejour") ~ "Basin",
      TRUE ~ "Basin"
    ),
    SiteID = paste0(SiteCode, "-T", `Transect number`, "-P", `Plot number`),
    X = `_Record your current location_longitude`,
    Y = `_Record your current location_latitude`
  ) %>%
  # Calculate basal areas from tree counts
  mutate(
    # Red mangrove basal area
    RedBasalArea = (coalesce(`Red Mangrove trees (0-10mm DBH)`, 0) * pi * (5/2000)^2) +
                   (coalesce(`Red Mangrove trees (10-25mm DBH)`, 0) * pi * (17.5/2000)^2) +
                   (coalesce(`Red Mangrove trees (25-100mm DBH)`, 0) * pi * (62.5/2000)^2) +
                   (coalesce(`Red Mangrove trees (100-200mm DBH)`, 0) * pi * (150/2000)^2) +
                   (coalesce(`Red Mangrove trees (>200mm DBH)`, 0) * pi * (250/2000)^2),
    
    # Black mangrove basal area
    BlackBasalArea = (coalesce(`Black Mangrove trees (0-10mm DBH)`, 0) * pi * (5/2000)^2) +
                     (coalesce(`Black Mangrove trees (10-25mm DBH)`, 0) * pi * (17.5/2000)^2) +
                     (coalesce(`Black Mangrove trees (25-100mm DBH)`, 0) * pi * (62.5/2000)^2) +
                     (coalesce(`Black Mangrove trees (100-200mm DBH)`, 0) * pi * (150/2000)^2) +
                     (coalesce(`Black Mangrove trees (>200mm DBH)`, 0) * pi * (250/2000)^2),
    
    # White mangrove basal area
    WhiteBasalArea = (coalesce(`White Mangrove trees (0-10mm DBH)`, 0) * pi * (5/2000)^2) +
                     (coalesce(`White Mangrove trees (10-25mm DBH)`, 0) * pi * (17.5/2000)^2) +
                     (coalesce(`White Mangrove trees (25-100mm DBH)`, 0) * pi * (62.5/2000)^2) +
                     (coalesce(`White Mangrove trees (100-200mm DBH)`, 0) * pi * (150/2000)^2) +
                     (coalesce(`White Mangrove trees (>200mm DBH)`, 0) * pi * (250/2000)^2)
  ) %>%
  # Add placeholder canopy widths and heights (replace with actual data if available)
  mutate(
    RedCanopyWidth = 0,
    BlackCanopyWidth = 0,
    WhiteCanopyWidth = 0,
    RedTreeHeight = 0,
    BlackTreeHeight = 0,
    WhiteTreeHeight = 0
  ) %>%
  # Select final columns in target format
  select(SiteName, SiteType, SiteID, X, Y,
         BlackBasalArea, RedBasalArea, WhiteBasalArea,
         BlackCanopyWidth, RedCanopyWidth, WhiteCanopyWidth,
         BlackTreeHeight, RedTreeHeight, WhiteTreeHeight) %>%
  mutate(
    RedPresent = ifelse(RedBasalArea > 0, 1, 0),
    BlackPresent = ifelse(BlackBasalArea > 0, 1, 0),
    WhitePresent = ifelse(WhiteBasalArea > 0, 1, 0)
  )

# Extract environmental values using unclipped rasters but with consistent scaling
VegDataComplete <- read_rds(paste0(here::here(), "/data/VegDataECCC.rds")) %>%
  mutate(
    RedPresent = ifelse(RedBasalArea > 0, 1, 0),
    BlackPresent = ifelse(BlackBasalArea > 0, 1, 0),
    WhitePresent = ifelse(WhiteBasalArea > 0, 1, 0)
  ) %>%
  bind_rows(VegDataCompleteUpdate) %>%
  st_as_sf(coords = c("X", "Y"), crs = 4326) %>%
  st_transform(crs = crs(SoilVector)) %>%
  {bind_cols(.,
             # Extract from unclipped rasters but scale using clipped raster statistics
             FA = (asinh(terra::extract(FARasterRaw, ., method = "bilinear")[,2]) - FA_mean) / FA_sd,
             TWI = (asinh(terra::extract(TWIRasterRaw, ., method = "bilinear")[,2]) - TWI_mean) / TWI_sd,
             Elevation = (asinh(terra::extract(DEMRasterRaw, ., method = "bilinear")[,2]) - DEM_mean) / DEM_sd,
             DistanceToCoast = terra::extract(DistanceToCoastRaster, ., method = "bilinear")[,2],
             DistanceToRiver = terra::extract(DistanceToRiverRaster, ., method = "bilinear")[,2])} 

# Create datasets for modeling
VegDataCompleteBinomial <- bind_rows(
  VegDataComplete %>%
    select(SiteID, geometry, RedPresent, BlackPresent, WhitePresent,
           FA, TWI, Elevation, DistanceToCoast, DistanceToRiver),
  # Background points
  st_sample(GrenadaOutlineVector, size = 200) %>%
    st_sf() %>%
    mutate(
      RedPresent = 0, BlackPresent = 0, WhitePresent = 0,
      SiteID = paste0("BG-", 1:200)
    ) %>%
    {bind_cols(.,
               FA = (asinh(terra::extract(FARasterRaw, ., method = "bilinear")[,2]) - FA_mean) / FA_sd,
               TWI = (asinh(terra::extract(TWIRasterRaw, ., method = "bilinear")[,2]) - TWI_mean) / TWI_sd,
               Elevation = (asinh(terra::extract(DEMRasterRaw, ., method = "bilinear")[,2]) - DEM_mean) / DEM_sd,
               DistanceToCoast = terra::extract(DistanceToCoastRaster, ., method = "bilinear")[,2],
               DistanceToRiver = terra::extract(DistanceToRiverRaster, ., method = "bilinear")[,2])} %>%
    st_join(SoilVector) %>%
    select(SiteID, geometry, RedPresent, BlackPresent, WhitePresent,
           FA, TWI, Elevation, DistanceToCoast, DistanceToRiver)
) 

VegDataCompleteGamma <- VegDataComplete %>%
  mutate(across(contains("TreeHeight"), ~. + 0.01))
```



### Environmental Rasters{.tabset}

```{r ViewEnvironmentalRasters, echo=FALSE, results='asis', fig.height=6, fig.width=6}
# Define the rasters to visualize through processing stages
RasterList <- list(
 "Scaled FA" = EnvStack$FA,
  "Scaled TWI" = EnvStack$TWI,
  "Scaled Elevation" = EnvStack$Elevation,
  "Scaled Distance to Coast" = EnvStack$DistanceToCoast,
  "Scaled Distance to River" =  EnvStack$DistanceToRiver
)

# Loop and plot each raster with ggplot using tidyterra
for(i in names(RasterList)) {
  cat("\n\n#### ", i, "\n\n")
  
  # tidyterra allows direct ggplot use with SpatRaster objects!
  p <- ggplot() +
    geom_spatraster(data = RasterList[[i]]) +
    coord_sf(expand = FALSE) +
    theme_minimal() +
    labs(title = i, fill = "") +
    {if(str_detect(i, "Soil|Land")) scale_fill_discrete(na.value = "white") else scale_fill_viridis_c(na.value = "white")} +
    {if(str_detect(i, "Soil"))  theme(axis.title = element_blank(),legend.position = "none")  else theme(axis.title = element_blank(),legend.position = "bottom") } 
   
  
  # Add vectors for context on some plots
  if(str_detect(i, "Coast")) {
    p <- p + geom_sf(data = GrenadaOutlineVector, fill = NA, color = "red", linewidth = 0.5)
  }
  if(str_detect(i, "River")) {
    p <- p + geom_sf(data = RiverVector, color = "blue", linewidth = 0.8)
  }

  
  print(p)
  cat("\n\n")
}
```

### Raster Distributions {.tabset}

```{r ViewRasterDistributions, echo=FALSE, results='asis', fig.height=4, fig.width=6}
library(ggplot2)
library(dplyr)
library(stringr)

# Define the rasters to visualize through processing stages
RasterList <- list(
  "Scaled FA" = EnvStack$FA,
  "Scaled TWI" = EnvStack$TWI,
  "Scaled Elevation" = EnvStack$Elevation,
  "Scaled Distance to Coast" = EnvStack$DistanceToCoast,
  "Scaled Distance to River" = EnvStack$DistanceToRiver
)

# Loop and create appropriate plots
for (i in names(RasterList)) {
  cat("\n\n####", i, "\n\n")

  if (str_detect(i, "Soil|Land")) {
    # Factor summary and bar plot
    p <- RasterList[[i]] |>
      as_tibble(xy = TRUE, na.rm = TRUE) |>
      count(value = factor(.data[[names(RasterList[[i]])[1]]])) |>
      ggplot(aes(x = str_wrap(value,20), y = n)) +
      geom_col(fill = "darkorange") +
      theme_minimal() +
      labs(
        title = paste("Category Counts for", i),
        x = i,
        y = "Count"
      ) +
      { if(str_detect(i, "Soil")) theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 45, hjust = 1)) else theme(plot.title = element_text(hjust = 0.5))}
  } else {
    # Continuous raster histogram
    p <- RasterList[[i]] |>
      as_tibble(xy = TRUE, na.rm = TRUE) |>
      ggplot(aes(x = .data[[names(RasterList[[i]])[1]]])) +
      geom_histogram(fill = "steelblue", bins = 30) +
      theme_minimal() +
      labs(
        title = paste("Distribution of", i),
        x = "Value",
        y = "Density"
      ) +
      theme(plot.title = element_text(hjust = 0.5))
  }

  print(p)
  cat("\n\n")
}

```







### Correlation Plot 

```{r CorrelationPlot, echo=FALSE}
# Correlation plot for environmental variables
library(corrplot)


# Create correlation plot
corrplot(cor(VegDataComplete %>%
  st_drop_geometry() %>%
  select(TWI, FA, Elevation, DistanceToCoast, DistanceToRiver) %>%
  na.omit()), 
         method = "color",
         type = "upper",
         order = "hclust",
         tl.cex = 0.8,
         tl.col = "black",
         tl.srt = 45,
         addCoef.col = "black",
         number.cex = 0.7,
         title = "Environmental Variable Correlations",
         mar = c(0,0,1,0))

```


# Model Selection Approach

We developed a two-model framework to distinguish between factors controlling mangrove establishment versus growth performance, using different statistical approaches for each question.

## Two-Model Framework
**Binomial models (presence/absence)**: Predict where each species can establish across the landscape using logistic regression. We added 200 background points randomly distributed across soil polygons to provide proper presence/absence contrast, following standard species distribution modeling practices. Background points represent "available" environmental conditions where mangroves could potentially occur but were not surveyed.

**Gamma models (tree height)**: Predict growth performance at locations where species are already established, using only our field survey points. We added 0.01m to all height measurements to handle true zeros for the Gamma distribution.

## Statistical Distribution Choice
Initially, we attempted Tweedie distribution, which seemed ideal for zero-inflated continuous data (tree heights with true zeros). However, Tweedie models with fixed variance parameters (we used 1.5 for compound Poisson-gamma distribution) cannot calculate likelihood-based statistics like AIC, preventing model comparison. 

Gamma distribution with log link provided a robust alternative by handling right-skewed positive data while enabling proper model comparison. The small constant addition (0.01m) converts zero-inflated data to strictly positive without changing biological interpretation.

## Environmental Variables and Transformations
We tested topographic wetness index (TWI), flow accumulation (FA), elevation, and soil type as predictors. Flow accumulation required log transformation due to extreme values causing convergence issues. All continuous variables were scaled to improve model stability and enable coefficient comparison.

## Model Complexity Testing
We systematically tested model complexity from simple (single predictors) to complex (three-way interactions), including:

- **Single effects**: Individual environmental drivers
- **Additive effects**: Combined environmental influences  
- **Two-way interactions**: Ecologically meaningful synergistic effects
  - *TWI × Flow Accumulation*: Soil moisture vs. waterlogging trade-offs
  - *TWI × Soil Type*: Groundwater effects varying by soil characteristics
  - *Elevation × Flow Accumulation*: Tidal influence vs. storm surge patterns
- **Soil interactions**: How environmental factors interact with edaphic conditions

This systematic approach identified that simple environmental gradients control establishment, while complex environmental interactions (particularly for Red mangroves) or unmeasured factors control growth performance, providing clear guidance for restoration site selection and performance expectations.



```{r BuildModels, include=FALSE}
# Generate ALL possible model combinations - with LandUse as control
Variables <- c("DistanceToCoast", "DistanceToRiver", "FA", "TWI", "Elevation")
# Create all possible pairs  
AllPairs <- combn(Variables, 2, simplify = FALSE)

# Generate models for core variables (your existing code)
ModelFormulas <- c(
  
  # For each subset of variables, generate all interaction patterns
  expand_grid(
    DistanceToCoast = c(0, 1),
    DistanceToRiver = c(0, 1),
    FA = c(0, 1),
    TWI = c(0, 1),
    Elevation = c(0, 1)
  ) %>%
    filter(rowSums(across(everything())) > 0) %>%  # Remove null case
    rowwise() %>%
    mutate(
      SelectedVars = list(Variables[c(DistanceToCoast, DistanceToRiver, FA, TWI, Elevation) == 1]),
      ValidPairs = list(AllPairs[map_lgl(AllPairs, ~ all(.x %in% SelectedVars))])
    ) %>%
    pmap(function(...) {
      row <- list(...)
      selected_vars <- row$SelectedVars
      valid_pairs <- row$ValidPairs
      
      if(length(valid_pairs) == 0) {
        # No valid pairs - only additive model possible
        name <- if(length(selected_vars) == 1) {
          paste0(selected_vars[[1]], "_only")
        } else {
          paste(selected_vars, collapse = "_")
        }
        formula <- paste("~", paste(selected_vars, collapse = " + "))
        return(setNames(list(formula), name))
      }
      
      # Generate all possible interaction patterns
      num_pairs <- length(valid_pairs)
      results <- list()
      
      for(pattern in 0:(2^num_pairs - 1)) {
        # Determine which pairs are interactive
        interactive_pairs <- valid_pairs[as.logical(intToBits(pattern)[1:num_pairs])]
        
        # Build formula
        if(length(interactive_pairs) == 0) {
          # No interactions - just additive
          formula_parts <- selected_vars
          interaction_suffix <- ""
        } else {
          # Build interactions
          interactions <- map_chr(interactive_pairs, ~ paste(.x, collapse = " * "))
          
          # Get variables covered by interactions
          covered_vars <- unique(unlist(interactive_pairs))
          uncovered_vars <- setdiff(selected_vars, covered_vars)
          
          # Combine uncovered main effects with interactions
          formula_parts <- c(uncovered_vars, interactions)
          
          # Create suffix for naming
          interaction_names <- map_chr(interactive_pairs, ~ paste(.x, collapse = "x"))
          interaction_suffix <- paste0("_", paste(interaction_names, collapse = "_"))
        }
        
        formula <- paste("~", paste(formula_parts, collapse = " + "))
        
        # Create descriptive name
        if(length(selected_vars) == 1) {
          name <- paste0(selected_vars[[1]], "_only")
        } else {
          base_name <- paste(selected_vars, collapse = "_")
          name <- paste0(base_name, interaction_suffix)
        }
        
        results[[name]] <- formula
      }
      
      results
    }) %>%
    flatten()
)

ModelFormulasBinomial <- ModelFormulas
names(ModelFormulasBinomial) <- paste0(names(ModelFormulas), "_Binomial")

# Filter out models with distance variables
ModelFormulasBinomial <- ModelFormulasBinomial[!str_detect(names(ModelFormulasBinomial), "Coast|River")]


# Check how many models we generated
cat("Total models generated:", length(ModelFormulas))




# Update your ModelGrid to include both model types correctly
ModelGrid <- expand_grid(
  Species = c("Red", "Black", "White"),
  ModelName = c(names(ModelFormulas), names(ModelFormulasBinomial))) %>%
  mutate(
    Response = case_when(
      str_detect(ModelName, "Binomial") ~ paste0(Species, "Present"),
      TRUE ~ paste0(Species, "TreeHeight")
    ),
    ModelType = ifelse(str_detect(ModelName, "Binomial"), "Binomial", "Gamma")
  )

SaveModelsAll <-
  map_dfr(1:nrow(ModelGrid), function(i){
    
    row <- ModelGrid[i, ]
    
    # Try to fit the model with error handling
    result <- tryCatch({
      
      # In the model fitting section:
      if(row$ModelType == "Binomial") {
        formula <- as.formula(paste0(row$Response, ModelFormulasBinomial[[row$ModelName]]))
        model <- glm(formula, family = binomial, data = VegDataCompleteBinomial)
      } else {
        formula <- as.formula(paste0(row$Response, ModelFormulas[[row$ModelName]]))
        model <- glm(formula, family = Gamma(link = "log"),
                     data = VegDataCompleteGamma
        )
      }
      
      # Get predictions
      predictions <- predict(model, type = "response")
      
      # Return successful results
      tibble(
        Species = row$Species,
        ModelName = row$ModelName,
        ModelResponse = row$Response,
        ModelType = row$ModelType,
        AIC = AIC(model),
        BIC = BIC(model),
        PseudoR2 = 1 - (deviance(model) / model$null.deviance),
        ModelStatus = if(any(is.na(coef(model)))) "Failed: NA coefficients" else "Success"
      )
      
    }, error = function(e) {
      # Return failure results with NAs
      tibble(
        Species = row$Species,
        ModelName = row$ModelName,
        ModelResponse = row$Response,
        ModelType = row$ModelType,
        AIC = NA_real_,
        BIC = NA_real_,
        PseudoR2 = NA_real_,
        ModelStatus = paste("Failed:", e$message)
      )
    })
    
    return(result)
  })
```


# Overall Model Results Summary

**The models reveal that establishment and performance are governed by different environmental processes:**

### Red Mangrove
- **Establishment**: Controlled by combined environmental gradients (TWI + FA + Elevation), requiring integration of groundwater, surface water, and elevation-mediated processes including tidal exposure, salinity, and drainage
- **Performance**: Complex TWI × soil type interaction (R² = 0.56), where groundwater accessibility effects depend on edaphic characteristics, suggesting fine-scale soil-hydrology feedbacks control growth

### Black Mangrove  
- **Establishment**: Controlled by elevation, which integrates key environmental constraints including tidal stress, salinity gradients, and hydroperiod
- **Performance**: Also controlled by elevation, indicating consistent responses to elevation-mediated environmental conditions throughout the species' life cycle and making this the most predictable species across both life stages

### White Mangrove
- **Establishment**: Controlled by elevation, occupying specific elevation niches that integrate appropriate tidal exposure, drainage, and salinity conditions
- **Performance**: Unpredictable from measured environmental variables, where within suitable elevation zones, unmeasured factors such as genetics, microsite conditions, and disturbance history appear to dominate growth variation

**Key insight**: Elevation emerges as a primary predictor not as a direct driver, but as an integrative proxy for multiple environmental processes including tidal exposure frequency, salinity gradients, soil drainage, and freshwater influence. Species respond to elevation-mediated environmental conditions rather than elevation per se.

## Top Models
```{r ViewReuls}

SaveModelsAll%>% ungroup()%>% filter(!is.infinite(PseudoR2), !PseudoR2<0, ModelStatus == "Success")%>%
  group_by(Species, ModelType) %>%
  mutate(DeltaAIC = AIC - min(AIC, na.rm = TRUE),
         DeltaBIC = BIC - min(BIC, na.rm = TRUE),
         ModelName = str_wrap(ModelName, 10)) %>% ungroup()%>%filter(DeltaAIC<2)%>% 
  select(Species:ModelResponse, PseudoR2, DeltaAIC, DeltaBIC)%>% 
  mutate(DeltaAIC = round(DeltaAIC, 3),
          DeltaBIC = round(DeltaBIC, 3),
         PseudoR2 = scales::percent(round(PseudoR2, 3)),
         )%>% DT::datatable()

```




```{r BestThresholds, echo=FALSE, results='asis'}
library(pROC)
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)

# Get top models
TopModels <- SaveModelsAll %>%
  ungroup() %>% 
 filter(!is.infinite(PseudoR2), !PseudoR2<0, ModelStatus == "Success")%>%
  group_by(Species, ModelType) %>%
  mutate(DeltaAIC = AIC - min(AIC, na.rm = TRUE)) %>%
  filter(DeltaAIC < 2) %>%
  group_by(Species, ModelResponse) %>%
  slice_min(AIC, n = 1) %>%  # Take best model per species/response
  ungroup()

# Function to calculate optimal thresholds and create ROC analysis
CalculateOptimalThresholds <- function(ModelName, Species, ModelResponse, ModelObject) {
  
  # Use the right dataset for each model type
  if(str_detect(ModelResponse, "Present")) {        
    YourData <- VegDataCompleteBinomial  # Presence models use binomial data
  } else {   
    YourData <- VegDataCompleteGamma     # Height models use gamma data
  }
  
  # Get observed values
  ObservedColumn <- case_when(
    str_detect(ModelResponse, "Red") & str_detect(ModelResponse, "Present") ~ "RedPresent",
    str_detect(ModelResponse, "Black") & str_detect(ModelResponse, "Present") ~ "BlackPresent", 
    str_detect(ModelResponse, "White") & str_detect(ModelResponse, "Present") ~ "WhitePresent",
    TRUE ~ ModelResponse
  )
  
  Observed <- YourData[[ObservedColumn]]
  Predictions <- predict(ModelObject, newdata = YourData, type = "response")
  
  # Clean observed/prediction data for binomial models
  if(str_detect(ModelResponse, "Present")) {
    Observed <- as.numeric(Observed)
    valid <- !is.na(Observed) & !is.na(Predictions)
    Observed <- Observed[valid]
    Predictions <- Predictions[valid]
    
    if(!all(Observed %in% c(0, 1))) {
      warning(paste("Non-binary values found in", ObservedColumn, "- converting to 0/1"))
      Observed <- ifelse(Observed > 0, 1, 0)
    }
  }

  # Create ROC curve
  RocCurve <- roc(Observed, Predictions, quiet = TRUE)
  
  # Define all thresholds to evaluate
  threshold_labels <- c("Youden", "ClosestTopLeft", "Prevalence", "Conservative", "Moderate", "Liberal")
  threshold_values <- c(
    as.numeric(coords(RocCurve, "best", ret = "threshold", best.method = "youden")),
    as.numeric(coords(RocCurve, "best", ret = "threshold", best.method = "closest.topleft")),
    as.numeric(mean(Observed, na.rm = TRUE)),
    0.5,
    0.3,
    0.1
  )
  
  # Helper function to calculate metrics at a given threshold
  CalculateMetricsAtThreshold <- function(threshold, Observed, Predictions) {
    PredictedClass <- ifelse(Predictions >= threshold, 1, 0)
    
    TP <- sum(Observed == 1 & PredictedClass == 1)
    TN <- sum(Observed == 0 & PredictedClass == 0)
    FP <- sum(Observed == 0 & PredictedClass == 1)
    FN <- sum(Observed == 1 & PredictedClass == 0)
    
    sensitivity <- ifelse((TP + FN) > 0, TP / (TP + FN), NA)
    specificity <- ifelse((TN + FP) > 0, TN / (TN + FP), NA)
    accuracy    <- (TP + TN) / (TP + TN + FP + FN)
    f1_score    <- ifelse((2 * TP + FP + FN) > 0, 2 * TP / (2 * TP + FP + FN), NA)
    balanced_acc <- mean(c(sensitivity, specificity), na.rm = TRUE)
    
    list(Sensitivity = sensitivity,
         Specificity = specificity,
         Accuracy = accuracy,
         F1 = f1_score,
         BalancedAccuracy = balanced_acc)
  }

  # Loop through thresholds and compile results
  ThresholdResults <- map2_dfr(threshold_labels, threshold_values, function(label, th) {
    metrics <- CalculateMetricsAtThreshold(th, Observed, Predictions)
    
    tibble(
      Species = Species,
      ModelResponse = ModelResponse,
      ModelName = ModelName,
      Method = label,
      Threshold = th,
      AUC = as.numeric(RocCurve$auc),
      Sensitivity = metrics$Sensitivity,
      Specificity = metrics$Specificity,
      Accuracy = metrics$Accuracy,
      F1 = metrics$F1,
      BalancedAccuracy = metrics$BalancedAccuracy
    )
  })
  
  return(ThresholdResults)
}


# Map across each model row to get threshold results
AllThresholdResults <- pmap_dfr(TopModels %>%
  filter(ModelType == "Binomial"), function(Species, ModelResponse, ModelName, ModelType, ...) {
  
  # Get model formula
  FormulaString <- ModelFormulas[[str_remove(ModelName, "_Binomial$")]]
  FullFormula <- as.formula(paste0(ModelResponse, FormulaString))
  
  # Fit model using correct dataset
  ModelObject <- if (str_detect(ModelResponse, "Present")) {
    glm(FullFormula, family = binomial, data = VegDataCompleteBinomial)
  } else {
    glm(FullFormula, family = Gamma(link = "log"), data = VegDataCompleteGamma)
  }
  
  # Calculate thresholds
  RocResults <- CalculateOptimalThresholds(
    ModelName = ModelName,
    Species = Species,
    ModelResponse = ModelResponse,
    ModelObject = ModelObject
  )
  
  return(RocResults)
})

library(ggplot2)

AllThresholdResults %>%
  ggplot(aes(x = Threshold, y = BalancedAccuracy, color = Species)) +
  geom_point(aes(shape = Method), size = 3) +
  geom_line() +
  facet_wrap(~ Species) +
  theme_minimal() +
  labs(title = "Threshold vs Balanced Accuracy by Species",
       x = "Threshold", y = "Balanced Accuracy") +
  theme(legend.position = "bottom")



TopThresholds <- AllThresholdResults %>%
  group_by(Species) %>%
  filter(Specificity == max(Specificity, na.rm = TRUE)) %>%
  slice_max(AUC, n = 1) %>%
  ungroup()


```


```{r ViewModels, results='asis'}
# Function to create coefficient plot for a model
CreateCoefficientPlot <- function(ModelObject, Species, ModelResponse, ModelType) {
  
  # Extract coefficient summary
  coef_summary <- summary(ModelObject)$coefficients
  
  # Create a tibble with coefficient information
  # Handle different column names for binomial vs gamma models
  if(ModelType == "Binomial") {
    coef_data <- tibble(
      Variable = rownames(coef_summary),
      Estimate = coef_summary[, "Estimate"],
      StdError = coef_summary[, "Std. Error"],
      ZValue = coef_summary[, "z value"],
      PValue = coef_summary[, "Pr(>|z|)"]
    )
  } else {
    coef_data <- tibble(
      Variable = rownames(coef_summary),
      Estimate = coef_summary[, "Estimate"],
      StdError = coef_summary[, "Std. Error"],
      ZValue = coef_summary[, "t value"],
      PValue = coef_summary[, "Pr(>|t|)"]
    )
  }
  
  # Continue with the rest of the data processing
  coef_data <- coef_data %>%
    # Remove intercept for cleaner visualization
    filter(Variable != "(Intercept)") %>%
    # Calculate confidence intervals
    mutate(
      CI_Lower = Estimate - 1.645 * StdError,
      CI_Upper = Estimate + 1.645 * StdError,
      # Clean up variable names for better display
      Variable_Clean =  Variable,
      # Determine significance
      Significant = ifelse(PValue < 0.10, "Significant", "Non-significant"),
      # Determine effect direction
      Effect_Direction = ifelse(Estimate > 0, "Positive", "Negative")
    ) %>%
    # Order by absolute coefficient value for better visualization
    arrange(desc(abs(Estimate)))
  
  # Create the coefficient plot with different subtitle based on model type
  subtitle_text <- ifelse(ModelType == "Binomial", 
                         "Environmental Effects on Presence Probability (90% CI)",
                         "Environmental Effects on Tree Height (90% CI)")
  
  x_label <- ifelse(ModelType == "Binomial",
                   "Coefficient Estimate (Log-Odds Scale)",
                   "Coefficient Estimate (Log Scale)")
  
  coef_plot <- ggplot(coef_data, aes(x = Estimate, y = reorder(Variable_Clean, Estimate))) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray60", alpha = 0.8) +
    geom_errorbarh(aes(xmin = CI_Lower, xmax = CI_Upper, color = Significant), 
                   height = 0.3, size = 0.8, alpha = 0.8) +
    geom_point(aes(color = Significant, shape = Effect_Direction), 
               size = 3, stroke = 1) +
    scale_color_manual(values = c("Significant" = "#E31A1C", "Non-significant" = "#999999"),
                       name = "Significance\n(p < 0.05)") +
    scale_shape_manual(values = c("Positive" = 16, "Negative" = 17),
                       name = "Effect\nDirection") +
    labs(
      title = paste(Species, "Mangrove -", ifelse(ModelType == "Binomial", "Presence", "Height"), "Model Coefficients"),
      subtitle = subtitle_text,
      x = x_label,
      y = "Environmental Variables"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 12, face = "bold"),
      plot.subtitle = element_text(size = 10),
      axis.title.y = element_text(size = 11),
      axis.text.y = element_text(size = 9),
      legend.position = "bottom",
      legend.box = "horizontal",
      panel.grid.minor.x = element_blank(),
      panel.grid.major.y = element_line(color = "gray90", size = 0.5)
    ) +
    guides(
      color = guide_legend(override.aes = list(shape = 16)),
      shape = guide_legend(override.aes = list(color = "black"))
    )
  
  return(coef_plot)
}

# Initialize coefficient plots storage
AllCoefficientPlots <- list()

# Process each top model to create coefficient plots
for(i in 1:nrow(TopModels)) {
  
  ModelRow <- TopModels[i, ]
  
  # Get formula from ModelFormulas list and fit the model
  if(ModelRow$ModelType == "Binomial") {
        FormulaString <- ModelFormulasBinomial[[ModelRow$ModelName]]
    } else {
        FormulaString <- ModelFormulas[[ModelRow$ModelName]]
    }
  # Build the full formula with response variable
  FullFormula <- as.formula(paste0(ModelRow$ModelResponse, FormulaString))
  
  # Fit the model based on model type with error handling
  tryCatch({
    if(ModelRow$ModelType == "Binomial") {
      ModelObject <- glm(FullFormula, family = binomial, data = VegDataCompleteBinomial)
    } else {
      ModelObject <- glm(FullFormula, family = Gamma(link = "log"), data = VegDataCompleteGamma)
    }
    
    # Create and store coefficient plot only if model fitted successfully
    CoefPlotName <- paste(ModelRow$Species, ModelRow$ModelType, "Coefficients")
    AllCoefficientPlots[[CoefPlotName]] <- CreateCoefficientPlot(ModelObject, ModelRow$Species, ModelRow$ModelResponse, ModelRow$ModelType)
    
  }, error = function(e) {
    cat("Model failed for", ModelRow$Species, ModelRow$ModelType, ":", e$message, "\n")
  })
}

# Display coefficient plots
cat("## Model Coefficients and Environmental Effects\n\n")

if(length(AllCoefficientPlots) > 0) {
  # Display each coefficient plot
  for(i in 1:length(AllCoefficientPlots)) {
    cat("### ", names(AllCoefficientPlots)[i], "\n\n")
    print(AllCoefficientPlots[[i]])
    cat("\n\n")
  }
} else {
  cat("No coefficient plots generated.\n")
}

```


# Landscape-Scale Restoration Suitability 

The maps above integrate our species distribution models to provide actionable guidance for mangrove restoration across Grenada. We created presence probability maps for each species using the best-performing binomial models (probability of establishment), with additional height predictions available only for Red mangrove where growth performance could be reliably modeled.

**Presence Probability Maps** show the likelihood of successful species establishment across the landscape, derived from our top-performing models. These maps identify suitable habitat zones based on environmental conditions, with probabilities above 50% indicating areas with high establishment potential suitable for restoration investment.

**Expected Height Maps** (Red mangrove only) multiply probability of occurrence by predicted tree height, providing estimates of both establishment likelihood and growth performance. These maps account for the complex soil-hydrology interactions that control Red mangrove growth, offering comprehensive restoration suitability assessment.

**Conditional Height Maps** (Red mangrove only) show predicted tree height in areas where establishment probability exceeds 50%, filtering predictions to focus on reliable growth zones. These maps are particularly valuable for site-specific restoration planning where growth performance expectations are critical.

**Species Combination Analysis** synthesizes all presence predictions to identify zones where different species combinations can establish, enabling restoration practitioners to select appropriate species assemblages for different environmental conditions. This analysis reveals that most suitable habitat supports White mangrove, with Red and Black mangroves occupying more specialized niches that typically overlap with White mangrove habitat.

The integrated approach enables evidence-based restoration decisions by balancing establishment risk against performance potential, supporting both broad landscape planning and fine-scale site selection across Grenada's coastal wetlands.

## Maps{.tabset}

```{r ViewModels, include=FALSE}
# Get the top models using same filtering as your results
# Get top models
TopModels <- SaveModelsAll %>%
  ungroup() %>% 
 filter(!is.infinite(PseudoR2), !PseudoR2<0, ModelStatus == "Success")%>%
  group_by(Species, ModelType) %>%
  mutate(DeltaAIC = AIC - min(AIC, na.rm = TRUE)) %>%
  filter(DeltaAIC < 2) %>%
  group_by(Species, ModelResponse) %>%
  slice_min(AIC, n = 1) %>%  # Take best model per species/response
  ungroup()




# Create combined maps - only for species with both presence AND height models
CombinedMaps <- map_dfr(c("Red", "Black", "White"), function(species){
  
  cat("Processing", species, "mangrove models...\n")
  
  # Get top models for this species
  presence_model_row <- TopModels %>% filter(Species == species, ModelType == "Binomial")
  height_model_row <- TopModels %>% filter(Species == species, ModelType == "Gamma")
  
  # Check if both models exist
  if(nrow(presence_model_row) == 0) {
    cat("No presence model found for", species, "\n")
    return(tibble(Species = species, ExpectedHeight = list(NULL), ConditionalHeight = list(NULL)))
  }
  
  # Fit presence model and predict
  cat("Fitting presence model:", presence_model_row$ModelName, "\n")
  presence_formula <- as.formula(paste0(presence_model_row$ModelResponse, ModelFormulasBinomial[[presence_model_row$ModelName]]))
  presence_model <- glm(presence_formula, family = binomial, data = VegDataCompleteBinomial)
  
  # Create prediction stack for presence, masking unknown soil values
  presence_stack <- EnvStack
  if(str_detect(presence_model_row$ModelName, "Soil")) {
    # Get soil values that were in the training data
    training_soil_values <- VegDataCompleteBinomial$S_SORT %>% unique() %>% na.omit()
    # Mask unknown soil values
    presence_stack$S_SORT[!presence_stack$S_SORT %in% training_soil_values] <- NA
    cat("Masked unknown soil values for presence model\n")
  }
  
  # Predict presence using masked rasters
  cat("Predicting presence across landscape...\n")
 # Predict probability of presence

  
presence_map <- predict(presence_stack, presence_model, type = "response")

  
  # Only create height maps if height model exists
  if(nrow(height_model_row) > 0) {
    # Fit height model and predict  
    cat("Fitting height model:", height_model_row$ModelName, "\n")
    height_formula <- as.formula(paste0(height_model_row$ModelResponse, ModelFormulas[[height_model_row$ModelName]]))
    height_model <- glm(height_formula, family = Gamma(link = "log"), data = VegDataCompleteGamma)
    
    # Create prediction stack for height, masking unknown soil values
    height_stack <- EnvStack
  
    if(str_detect(height_model_row$ModelName, "Soil")) {
      # Get soil values that were in the height training data
      training_soil_values <- VegDataCompleteGamma$S_SORT %>% unique() %>% na.omit()
      # Mask unknown soil values
      height_stack$S_SORT[!height_stack$S_SORT %in% training_soil_values] <- NA
      cat("Masked unknown soil values for height model\n")
    }
    
    # Predict height using masked rasters
    cat("Predicting height across landscape...\n")
    height_map <- predict(height_stack, height_model, type = "response")
    
    # Create combined maps
    expected_height <- presence_map * height_map
    conditional_height <- mask(height_map, presence_map)

    
    cat("Created combined height maps for", species, "\n")
    
  } else {
    # No height model - set to NULL
    cat("No height model available for", species, "\n")
    expected_height <- NULL
    conditional_height <- NULL
  }
  
  cat("Completed", species, "mangrove processing\n\n")
  
  # Return appropriate maps based on what models exist
  if(nrow(height_model_row) > 0) {
    # Has both presence and height models
    tibble(
      Species = species,
      PresenceMap = list(presence_map),
      ExpectedHeight = list(expected_height),
      ConditionalHeight = list(conditional_height)
    )
  } else {
    # Only has presence model
    tibble(
      Species = species,
      PresenceMap = list(presence_map),
      ExpectedHeight = list(NULL),
      ConditionalHeight = list(NULL)
    )
  }
})
```


```{r ViewMaps, echo=FALSE, results='asis'}
for(i in 1:nrow(CombinedMaps)) {
  
  species <- CombinedMaps$Species[i]
  presence_map <- CombinedMaps$PresenceMap[[i]]
  expected_map <- CombinedMaps$ExpectedHeight[[i]]
  conditional_map <- CombinedMaps$ConditionalHeight[[i]]
  
  cat("\n\n### ", species, " Mangrove {.tabset}\n\n")
  
  # Always show presence map
  cat("\n\n#### Presence Probability\n\n")
  
  p1 <- ggplot() +
    geom_spatraster(data = presence_map) +
    coord_sf(expand = FALSE) +
    theme_minimal() +
    labs(title = paste(species, "Mangrove - Presence Probability"),
         subtitle = "Probability of species occurrence",
         fill = "Probability") +
    theme(axis.title = element_blank(),
          legend.position = "bottom") +
    scale_fill_viridis_c(na.value = "transparent")
  
  print(p1)
  
  # Only show height maps if they exist (not NULL)
  if(!is.null(expected_map)) {
    cat("\n\n### Expected Height\n\n")
    
    p2 <- ggplot() +
      geom_spatraster(data = expected_map) +
      coord_sf(expand = FALSE) +
      theme_minimal() +
      labs(title = paste(species, "Mangrove - Expected Height"),
           subtitle = "Probability of occurrence × Predicted height",
           fill = "Expected\nHeight (m)") +
      theme(axis.title = element_blank(),
            legend.position = "bottom") +
      scale_fill_viridis_c(na.value = "transparent")
    
    print(p2)
  }
  
  if(!is.null(conditional_map)) {
    cat("\n\n#### Conditional Height\n\n")
    
    p3 <- ggplot() +
      geom_spatraster(data = conditional_map) +
      coord_sf(expand = FALSE) +
      theme_minimal() +
      labs(title = paste(species, "Mangrove - Conditional Height"),
           subtitle = "Predicted height where probability > 50%",
           fill = "Height (m)") +
      theme(axis.title = element_blank(),
            legend.position = "bottom") +
      scale_fill_viridis_c(na.value = "transparent")
    
    print(p3)
  }
  
  cat("\n\n")
}
```


```{r SpeciesCombinationSummary, echo=FALSE, results='asis'}
# Four thresholding strategies, each defined as a filtering rule
# These help prioritize different conservation trade-offs:

ThresholdStrategies <- list(

  # 1. MaxBalancedAccuracy:
  # Balances sensitivity and specificity — avoids over- or under-predicting.
  # Use when both false positives and false negatives matter (general-purpose).
  MaxBalancedAccuracy = function(df) df %>%
    group_by(Species) %>%
    filter(BalancedAccuracy == max(BalancedAccuracy, na.rm = TRUE)) %>%
    slice_max(AUC, n = 1, with_ties = FALSE) %>%
    ungroup(),

  # 2. MaxSensitivity:
  # Maximizes detection of suitable areas — allows more false positives.
  # Use when *missing good sites* is worse than mistakenly including poor ones.
  MaxSensitivity = function(df) df %>%
    group_by(Species) %>%
    filter(Sensitivity == max(Sensitivity, na.rm = TRUE)) %>%
    slice_max(AUC, n = 1,with_ties = FALSE) %>%
    ungroup(),

  # 3. MaxSpecificity:
  # Maximizes certainty — avoids false positives.
  # Use when *acting on a false positive is costly* (e.g., failed planting).
  MaxSpecificity = function(df) df %>%
    group_by(Species) %>%
    filter(Specificity == max(Specificity, na.rm = TRUE)) %>%
    slice_max(AUC, n = 1,with_ties = FALSE) %>%
    ungroup(),
  
   # 4. Moderate:
# Applies a fixed threshold of 0.3 for all species — a predefined rule rather than one based on model-specific optimization.
# Use when you want consistency, interpretability, and to avoid overfitting.
# This strategy is helpful in planning contexts where a single, conservative decision rule is easier to communicate.
Moderate = function(df) df %>%
  filter(Method == "Moderate") %>%
  group_by(Species) %>%
  slice_max(AUC, n = 1, with_ties = FALSE) %>%
  ungroup()


)

# For each strategy, generate the corresponding species combination map
# Save the map and store it in a named list
CombinationMapSet <- imap(ThresholdStrategies, function(selector, name) {
  
  # Select optimal thresholds per species using the strategy's rule
  TopThresholds <- selector(AllThresholdResults)

  # Binary presence: Red = 1, Black = 2, White = 4 → combinations from sums
  CombinationMap <- ((CombinedMaps$PresenceMap[[1]] > TopThresholds$Threshold[TopThresholds$Species == "Red"])   * 1) +
                    ((CombinedMaps$PresenceMap[[2]] > TopThresholds$Threshold[TopThresholds$Species == "Black"]) * 2) +
                    ((CombinedMaps$PresenceMap[[3]] > TopThresholds$Threshold[TopThresholds$Species == "White"]) * 4)

  # Mask out unsuitable areas using land use raster (IDs 4–12, 15 = unsuitable)
  SuitableMask <- !LandUseRaster %in% c(4:12, 15)
  CombinationMap <- mask(CombinationMap, SuitableMask, maskvalue = FALSE)
  CombinationMap[is.na(CombinationMap)] <- 0

  # Set combination categories for display
  levels(CombinationMap) <- data.frame(
    ID = 1:7,
    Category = c("Red Only", "Black Only", "Red + Black",
                 "White Only", "Red + White", "Black + White", "All Three")
  )

  # Export map using PascalCase name to outputs folder
  OutputPath <- here::here("outputs", paste0("CombinationMap_", name, ".tif"))
  writeRaster(CombinationMap, OutputPath, overwrite = TRUE)

  # Return raster map to store in list
  return(CombinationMap)
})


```

```{r LoadSurveyVectors, include=FALSE}


# Import the survey plot polygons
surveyPlots <- st_read(paste0(here::here(),"/data/MangroveSurveyPlots_3857.gpkg"))

# Import the survey site points
surveySites <- st_read(paste0(here::here(),"/data/MangroveSurveySites_3857.gpkg"))


plotRasterBalanced <- as.factor(rast(here::here("outputs", paste0("CombinationMap_", "MaxBalancedAccuracy", ".tif"))) )
# Clean up raster: set 0 to NA if present
plotRasterBalanced[plotRasterBalanced == 0] <- NA

 levels(plotRasterBalanced) <- data.frame(
    ID = 1:7,
    Category = c("Red Only", "Black Only", "Red + Black",
                 "White Only", "Red + White", "Black + White", "All Three")
  )
 


```


## Final Map

```{r InteractiveSuitabilityMap, echo=FALSE}
library(leaflet)
library(htmlwidgets)
library(raster)
library(viridis)
library(sf)

# Ensure survey vectors are in WGS84 for Leaflet
surveySites <- st_transform(surveySites, 4326)
surveyPlots <- st_transform(surveyPlots, 4326)

# Fix invalid geometries
sf::sf_use_s2(FALSE)
surveySites <- st_make_valid(surveySites)
# REMOVED: st_centroid() - keeping surveySites as polygons

# Drop Z dimension, keep only XY for Leaflet
surveySites <- st_zm(surveySites, drop = TRUE, what = "ZM")
surveyPlots <- st_zm(surveyPlots, drop = TRUE, what = "ZM")

# Get category IDs and labels from raster levels
rasterLevels <- levels(plotRasterBalanced)[[1]]
rasterIds <- rasterLevels$ID
rasterLabels <- rasterLevels$Category

# Convert terra raster to raster for leaflet
plotRasterBalancedRaster <- raster::raster(plotRasterBalanced)

# Magma palette for suitability classes
magmaColors <- viridis::magma(length(rasterIds))

magmaPal <- colorFactor(
  palette = magmaColors,
  domain  = rasterIds,
  na.color = "transparent"
)

# Colors for survey site types (polygons)
siteTypeColors <- c(
  "White Mangrove (Laguncularia racemosa)" = "#fafafa",  # white
  "Red Mangrove (Rhizophora mangle)"       = "#e31a1c",  # red
  "Black Mangrove (Avicennia germinans)"   = "#6a3d9a",  # purple
  "Buttonwood (Conocarpus erectus)"        = "#ff7f00",  # orange
  "Mudflat (emerging mangrove habitat)"    = "#b15928",  # brown
  "Standing Water"                         = "#1f78b4",  # blue
  "Cleared"                                = "#ffff99"   # pale yellow
)

siteTypePal <- colorFactor(
  palette = siteTypeColors,
  levels  = names(siteTypeColors)
)

# Popup labels
sitePopups <- paste0(
  "<b>Site:</b> ", surveySites$Site.Name, "<br>",
  "<b>Type:</b> ", surveySites$Type
)

plotPopups <- paste0(
  "<b>Site:</b> ", surveyPlots$Site, "<br>",
  "<b>Transect:</b> ", surveyPlots$Transect, "<br>",
  "<b>Plot:</b> ", surveyPlots$Plot
)

# Build interactive map
# Build interactive map
webMap <- leaflet() |>
  addMapPane("rasterPane", zIndex = 250) |>
  addMapPane("polygonPane", zIndex = 350) |>
  addMapPane("markerPane", zIndex = 450) |>
  addProviderTiles("CartoDB.Positron", group = "Basemap") |>
  addRasterImage(
    plotRasterBalancedRaster,
    colors  = magmaPal,
    opacity = 0.8,
    project = TRUE,
    group   = "Suitability",
    options = leafletOptions(pane = "rasterPane")
  ) |>
  addLegend(
    position = "bottomright",
    colors   = magmaColors,
    labels   = rasterLabels,
    title    = "Species Combination",
    opacity  = 1
  ) |>
  addCircleMarkers(
    data        = surveyPlots,
    radius      = 3,
    stroke      = TRUE,
    weight      = 1,
    color       = "#444444",
    fillColor   = "#ffffff",
    fillOpacity = 0.9,
    popup       = plotPopups,
    group       = "Survey Plots",
    options     = leafletOptions(pane = "markerPane")
  ) |>
  addPolygons(
    data        = surveySites,
    stroke      = TRUE,
    weight      = 1,
    color       = ~siteTypePal(Type),
    fillColor   = ~siteTypePal(Type),
    fillOpacity = 0.7,
    popup       = sitePopups,
    group       = "Survey Sites",
    options     = leafletOptions(pane = "polygonPane")
  ) |>
  addLegend(
    position = "bottomleft",
    colors   = siteTypeColors,
    labels   = names(siteTypeColors),
    title    = "Survey Site Type",
    opacity  = 1
  ) |>
  addLayersControl(
    baseGroups    = c("Basemap"),
    overlayGroups = c("Suitability", "Survey Sites", "Survey Plots"),
    options       = layersControlOptions(collapsed = FALSE)
  ) |>
  setView(lng = -61.7, lat = 12.05, zoom = 11)

# Show in the RMarkdown
webMap

# Export to outputs folder as standalone HTML
htmlwidgets::saveWidget(
  widget       = webMap,
  file         = here::here("outputs", "MangroveSuitabilityInteractive.html"),
  selfcontained = TRUE
)
```

